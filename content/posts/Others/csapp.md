---
title: "CSapp"
date: 2026-02-03T20:47:16+08:00
draft: false
ShowToc: true
---

打算利用寒假的时间加深一点关于计算机系统的理解，在这里记一些关于CSapp的读书笔记，一方面加深理解，一方面可以供大家参考。
[原书导航(3-6章施工中)](https://hansimov.gitbook.io/csapp)

# Computer Systems∶A Programmer's Perspective

## 导论

**原课程**：[CMU 15-213](https://csdiy.wiki/en/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/CSAPP)
**作者**：Randal E. Bryant, David R. O'Hallaron
**出版时间**：2002/2010-2011/2015
**需要的背景知识**：C语言基础
**目标**：贯通地介绍执行x86-64机器代码的系统；增强工程能力
**目录**：

*第1章：计算机系统漫游*
这一章通过研究 “hello, world” 这个简单程序的生命周期，介绍计算机系统的主要概念和主题。

*第2章：信息的表示和处理*
我们讲述了计算机的算术运算，重点描述了会对程序员有 影响的无符号数和数的补码表示的特性。我们考虑数字是如何表示的，以及由此确定对于一个给定的字长，其可能编码值的范围。我们探讨有符号和无符号数字之间类型转换的效果，还阐述算术运算的数学特性。菜鸟级程序员经常很惊奇地了解到（用补码表示的）两个正数的和或者积可能为负。另一方面，补码的算术运算满足很多整数运算的代数特性，因此，编译器可以很安全地把一个常量乘法转化为一系列的移位和加法。我们用C 语言的位级操作来说明布尔代数的原理和应用。我们从两个方面讲述了 IEEE 标准的浮点格式：一是如何用它来表示数值，一是浮点运算的数学属性。

对计算机的算术运算有深刻的理解是写出可靠程序的关键。比如，程序员和编译器不能用表达式（x-y<0）来替代（x<y），因为前者可能会产生溢出。甚至也不能用表达式（-y<-x）来替代，因为在补码表示中负数和正数的范围是不对称的。算术溢出是造成程序错误和安全漏洞的一个常见根源，然而很少有书从程序员的角度来讲述计算机算术运算的特性。

*第3章：程序的机器级表示*
我们教读者如何阅读由 C 编译器生成的 x86-64 机器代码。我们说明为不同控制结构（比如条件、循环和开关语句）生成的基本指令模式。我们还讲述过程的实现，包括栈分配、寄存器使用惯例和参数传递。我们讨论不同数据结构（如结构、联合和数组）的分配和访问方式。我们还说明实现整数和浮点数算术运算的指令。我们还以分析程序在机器级的样子作为途径，来理解常见的代码安全漏洞（例如缓冲区溢出），以及理解程序员、编译器和操作系统可以采取的减轻这些威胁的措施。学习本章的概念能够帮助读者成为更好的程序员，因为你们懂得程序在机器上是如何表示的。另外一个好处就在于读者会对指针有非常全面而具体的理解。

*第4章：处理器体系结构*
这一章讲述基本的组合和时序逻辑元素，并展示这些元素如何在数据通路中组合到一起，来执行 x86-64 指令集的一个称为 “Y86-64” 的简化子集。我们从设计单时钟周期数据通路开始。这个设计概念上非常简单，但是运行速度不会太快。然后我们引入流水线的思想，将处理一条指令所需要的不同步骤实现为独立的阶段。这个设计中，在任何时刻，每个阶段都可以处理不同的指令。我们的五阶段处理器流水线更加实用。本章中处理器设计的控制逻辑是用一种称为 HCL 的简单硬件描述语言来描述的。用 HCL 写的硬件设计能够编译和链接到本书提供的模拟器中，还可以根据这些设计生成 Verilog 描述，它适合合成到实际可以运行的硬件上去。

*第5章：优化程序性能*
在这一章里，我们介绍了许多提高代码性能的技术，主要思想就是让程序员通过使编译器能够生成更有效的机器代码来学习编写 C 代码。我们一开始介绍的是减少程序需要做的工作的变换，这些是在任何机器上写任何程序时都应该遵循的。然后讲的是增加生成的机器代码中指令级并行度的变换，因而提高了程序在现代“超标量”处理器上的性能。为了解释这些变换行之有效的原理，我们介绍了一个简单的操作模型，它描述了现代乱序处理器是如何工作的，然后给出了如何根据一个程序的图形化表示中的关键路径来测量一个程序可能的性能。你会惊讶于对 C 代码做一些简单的变换能给程序带来多大的速度提升。

*第6章：存储器层次结构*
对应用程序员来说，存储器系统是计算机系统中最直接可见的部分之一。到目前为止，读者一直认同这样一个存储器系统概念模型，认为它是一个有一致访问时间的线性数组。实际上，存储器系统是一个由不同容量、造价和访问时间的存储设备组成的层次结构。我们讲述不同类型的随机存取存储器（RAM）和只读存储器（ROM），以及磁盘和✦固态硬盘✦的几何形状和组织构造。我们描述这些存储设备是如何放置在层次结构中的，讲述访问局部性是如何使这种层次结构成为可能的。我们通过一个独特的观点使这些理论具体化，那就是将存储器系统视为一个“存储器山”，山脊是时间局部性，而斜坡是空间局部性。最后，我们向读者阐述如何通过改善程序的时间局部性和空间局部性来提高应用程序的性能。

*第7章：链接*
本章讲述静态和动态链接，包括的概念有可重定位的和可执行的目标文件、符号解析、重定位、静态库、共享目标库、位置无关代码，以及库打桩。大多数讲述系统的书中都不讲链接，我们要讲述它是出于以下原因。第一，程序员遇到的最令人迷惑的问题中，有一些和链接时的小故障有关，尤其是对那些大型软件包来说。第二，链接器生成的目标文件是与一些像加载、虚拟内存和内存映射这样的概念相关的。

*第8章：异常控制* 
在本书的这个部分，我们通过介绍异常控制流（即除正常分支和过程调用以外的控制流的变化）的一般概念，打破单一程序的模型。我们给出存在于系统所有层次的异常控制流的例子，从底层的硬件异常和中断，到并发进程的上下文切换，到由于接收 Linux 信号引起的控制流突变，到 C 语言中破坏栈原则的非本地跳转。 在这一章，我们介绍进程的基本概念，进程是对一个正在执行的程序的一种抽象。读者会学习进程是如何工作的，以及如何在应用程序中创建和操纵进程。我们会展示应用程序员如何通过 Linux 系统调用来使用多个进程。学完本章之后，读者就能够编写带作业控制的 Linux shell 了。同时，这里也会向读者初步展示程序的并发执行会引起不确定的行为。

*第9章：虚拟内存*
我们讲述虚拟内存系统是希望读者对它是如何工作的以及它的特性有所了解。我们想让读者了解为什么不同的并发进程各自都有一个完全相同的地址范围，能共享某些页，而又独占另外一些页。我们还讲了一些管理和操纵虚拟内存的问题。特别地，我们讨论了存储分配操作，就像标准库的* malloc 和 free 操作。阐述这些内容是出于下面几个目的。它加强了这样一个概念，那就是虚拟内存空间只是一个字节数组，程序可以把它划分成不同的存储单元。它可以帮助读者理解当程序包含存储泄漏和非法指针引用等内存引用错误时的后果。最后，许多应用程序员编写自己的优化了的存储分配操作来满足应用程序的需要和特性。这一章比其他任何一章都更能展现将计算机系统中的硬件和软件结合起来阐述的优点。而传统的计算机体系结构和操作系统书籍都只讲述虚拟内存的某一方面。

*第10章：系统级 I/O* 
我们讲述 Unix I/O 的基本概念，例如文件和描述符。我们描述如何共享文件，I/O 重定向是如何工作的，还有如何访问文件的元数据。我们还开发了一个健壮的带缓冲区的 I/O 包，可以正确处理一种称为 short counts 的奇特行为，也就是库函数只读取一部分的输入数据。我们阐述 C 的标准 I/O 库，以及它与 Linux I/O 的关系，重点谈到标准 I/O 的局限性，这些局限性使之不适合网络编程。总的来说，本章的主题是后面两章——网络和并发编程的基础。

*第11章：网络编程* 
对编程而言，网络是非常有趣的 I/O 设备，它将许多我们前面文中学习的概念（比如进程、信号、字节顺序、内存映射和动态内存分配）联系在一起。网络程序还为下一章的主题——并发，提供了一个很令人信服的上下文。本章只是网络编程的一个很小的部分，使读者能够编写一个简单的 Web 服务器。我们还讲述位于所有网络程序底层的客户端-服务器模型。我们展现了一个程序员对 Internet 的观点，并且教读者如何用套接字接口来编写 Internet 客户端和服务器。最后，我们介绍超文本传输协议（HTTP），并开发了一个简单的迭代式 Web 服务器。

*第12章：并发编程* 
这一章以 Internet 服务器设计为例介绍了并发编程。我们比较对照了三种编写并发程序的基本机制（进程、I/O多路复用和线程），并且展示如何用它们来建造并发Internet服务器。我们探讨了用 P、V 信号量操作来实现同步、线程安全和可重入、竞争条件以及死锁等的基本原则。对大多数服务器应用来说，写并发代码都是很关键的。我们还讲述了线程级编程的使用方法，用这种方法来表达应用程序中的并行性，使得程序在多核处理器上能执行得更快。使用所有的核解决同一个计算问题需要很小心谨慎地协调并发线程，既要保证正确性，又要争取获得高性能。





## 第一章

### 1.1 信息就是位+上下文

- 文件
1.文本文件：只由ASCLL字符构成
2.二进制文件：除文本文件以外的文件

> 区分不同数据对象的唯一方法是我们读到这些数据对象时候的上下文。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令

- C语言：
1.与Unix操作系统关系密切
2.小而简单
3.为实践目的设计
4.适合系统级和应用级程序的编写
5.缺乏对一些有用抽象（比如类、对象和异常）的显式支持


### 1.2 程序的生命周期

开发端高级语言 ————> 可执行目标文件（打包好的低级机器语言指令）

编译系统：预处理器 -> 编译器 -> 汇编器 -> 链接器
 (hello.c -> hello.i -> hello.s -> hello.o -> hello)

.s：汇编语言程序（为不同高级语言的不同编译器提供了通用的输出语言）
.o：relocaatable object program

{{< notice abstract "Link" >}}
GNU 项目是 1984 年由 Richard Stallman 发起的一个免税的慈善项目。该项目的目标非常宏大，就是开发出一个完整的类 Unix 的系统，其源代码能够不受限制地被修改和传播。GNU 项目已经开发出了一个包含 Unix 操作系统的所有主要部件的环境，但内核除外，内核是由 Linux 项目独立发展而来的。GNU 环境包括 EMACS 编辑器、GCC 编译器、GDB 调试器、汇编器、链接器、处理二进制文件的工具以及其他一些部件。GCC 编译器已经发展到支持许多不同的语言，能够为许多不同的机器生成代码。支持的语言包括 C、C++、Fortran、Java、Pascal、面向对象 C 语言（Objective-C）和 Ada。
此外，GNU项目还推动了现代开源运动，并因为GNU工具为linux提供了环境而推动了linux的普及。
{{< /notice >}}


### 1.3 编译系统

- 通过了解编译系统是如何工作的有助于编写性能更好的程序。
- 更深刻地理解报错（链接）
-避免安全漏洞（静态的比如堆栈和缓冲区溢出）

### 1.4 处理器读并解释储存在内存中的指令

通过将文件名输入shell，可以在Unix系统中运行可执行文件

- shell：一个命令行解释器（应用程序）。输出提示符，等待命令，若不是内置shell命令，shell就会假设其为一个可执行文件的名字。

#### 1.4.1 系统的硬件组成

- **总线**
（1）贯穿系统的一组电子管道。
（2）携带信息字节并在各个部件间传递。
（3）通常设计成传送定长的字节块（Word）。
（4）32位机器，字长为4字节；64位机器，字长为8字节。

- **I/O设备**
（1）用户输入：键盘鼠标；用户输出：显示器；存储：磁盘驱动器。
（2）每个I/O设备都通过一个控制器或适配器与I/O总线相连。
（3）控制器是主板上的芯片组，适配器是插在主板卡槽上的卡，功能都是在I/O总线和I/O设备之间传递信息，区别在于封装的方式。

- **主存**
（1）临时存储设备
（2）物理上，贮存由一组DRAM芯片组成
（3）逻辑上，存储器是一个线性的字节数组，每个字节都有其唯一的地址

- **处理器**
（1）中央处理单元（CPU）
（2）解释/执行存储在主存中指令的引擎
（3）核心是PC，大小为一个字。从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。

register file(寄存器文件)：由一些单字长的寄存器组成的一个小的存储设备，每个寄存器都有唯一的名字。

一些可能的简单CPU操作如下：
（1）加载（load）：从主存加载数据到寄存器
（2）存储（store）：从寄存器
（3）ALU计算
（4）pc的条件/非条件跳转

![CPU](/images/csapp1.4.1.jpg)

指令集架构（ISA）：指令集、寄存器、数据类型的表示、寻址方式
微体系结构（Microarchitecture）：ISA具体的实现方法（更底层），包含流水线、cache、分支预测、执行单元等
> 如果ISA是菜单，微体系结构就是后厨


#### 1.4.2 运行hello程序

1.键入`./hello`，回车告知shell我们结束了命令的输入
2.shell执行一系列指令加载可执行文件，目标文件code和data从磁盘到主存
> 利用DMA（直接存储器）技术，数据从disc到memory不需要经过CPU
3.处理器开始执行主存中hello程序中main函数的机器语言指令
4."hello world\n"字符串中的字节从主存->reg file->显示设备


### 1.5高速缓存

1.4中讲到系统在运行程序的时候会花费大量时间转移数据，而这都是拖慢程序运行的额外开销。

根据机械原理：存储器容量越大，读取和存储速度越慢

所以处理器从regfile中读取数据比从memory中读取数据要快100倍，而且加快处理器的运行速度比加快主存的运行速度要容易和便宜得多，因此这种差距随着半导体技术的进步还在持续增大

- 针对这种差异，系统设计者设计了更快更小的存储设备：cache memory（高速缓存存储器）。

cache作为暂时的集结区域，存放处理器近期可能会需要的信息。

![cache](/images/csapp1.5.jpg)

- 高速缓存存在级联，目的是在增大缓存容量的同时保持访问速度

- L1
（1）位于处理器芯片上
（2）容量可达到数万字节
（3）访问速度几乎和访问寄存器一样快

- L2
（1）通过特殊的总线连接到处理器
（2）容量从数十万字节到百万字节
（3）访问速度比访问L1慢5倍，但依然比访问主存快5-10倍

- L3
比较新的、处理能力更强大的系统甚至有三级高速缓存∶L1、L2和L3


{{< notice abstract "SRAM" >}}
L1和L2高速缓存是通过静态随机存取存储器(SRAM,Static Random-Access Memory)实现的。
- 依靠触发器电路保持数据状态
- 只要通电，数据就永久保持，无需周期性刷新
- DRAM 需要定期刷新（动态），SRAM 不需要（静态）
- 通常由6个晶体管（6T）构成一个存储位
- 成本较高，速度为纳秒级，非常快
{{< /notice >}}

- 程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。

- 充分地利用高速缓存能将程序性能提高一个数量级



### 1.6 存储设备的层级结构

- 普遍观念：在处理器和一个较大较慢的设备（主存）之间插入更小更快的存储设备（cache）
- 主要思想：上一层的存储器作为低一层存储器的高速缓存

下面的图片是一个例子：
![存储结构](/images/csapp1.6.jpg)


### 1.7 操作系统

- OS：程序和硬件(CPU、memory、I/O...)之间插入的一层软件

- 基本功能：
（1）保护硬件（不被失控的应用程序滥用）
（2）向应用程序提供简单、一致的机制来控制硬件设备（种类、功能各异）

- 实现方式：进程、虚拟内存、文件等**抽象表示**
- 文件：I/O设备的抽象表示
- 虚拟内存：主存、I/O设备的抽象表示
- 进程：处理器、主存和I/O设备的抽象表示

{{< notice abstract "Link" >}}
- Unix：贝尔实验室的研究人员在六七十年代基于Multics的理念开发的一个简单得多的操作系统
- Posix标准：IEEE对Unix开发设立的标准。涵盖了C语言接口、shell 程序和工具、线程及网络编程等。与一系列标准化工作一起作用，使Unix版本之间的差异已经基本消失
{{< /notice >}}


#### 1.7.1 进程(Process)

- 进程是操作系统对一个正在运行的程序的一种抽象

- 作用：帮助操作系统会提供一种假象，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器、主存和I/O设备。处理器看上去就像在不间断地一条接一条地执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象。

- 在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件

- 并发运行：处理器交错执行进程间的指令，通过上下文（PC、regs）切换运行
（进程的转换通过**系统调用(system call)**来实现，转换的过程由内核来完成）

- 内核：不是一个独立的进程，而是系统管理全部进程所用代码和数据结构的集合。


#### 1.7.2 线程(Thread)

- 一个进程实际上可以由多个称为**线程**的执行单元组成
- 每个线程都运行在进程的上下文中，并共享同样的代码和全局数据
- 因为更容易共享数据，使用线程可以更好地满足网络服务器中的并行处理需求


#### 1.7.3 虚拟内存(Virtual Memory)

- 一个抽象概念
- 为每个进程提供一个假象：即每个进程都在独占地使用主存

下图为Linux的虚拟地址空间：
![virtual-memory](/images/csapp1.7.3.jpg)

- 虚拟内存的运作需要**硬件和操作系统**之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存


#### 1.7.4 文件

- 字节序列。仅此而已。每个I/O设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件

- 向应用程序提供了一个统一的视图来看待系统中各式各样的I/O设备。e.g.处理磁盘文件内容的硬件程序员可以无需了解具体的磁盘技术。进一步说，同一个程序可以在使用不同磁盘技术的不同系统上运行


### 1.8 系统之间的网络通信

- 从一个单独的系统来看，网络可以视为一个I/O设备（网络适配器）

利用telnet通过网络远程运行hello
![telnet](/images/csapp1.8.jpg)



### 1.9 重要主题

- 系统是硬件和软件交织而成的集合体，它们协同运作达到**运行应用程序**的最终目的

#### 1.9.1 Amdahl定律

- 主要观点：要想显著加速整个系统，必须提升全系统中相当大的部分的速度。

计算加速比


#### 1.9.2 并发和并行

- 并发(concurrency)：指一个同时具有多个活动的系统，是一个一般概念。
- 并行(parallelism)：用并发来使系统运行的更快，是一个策略。

1.线程级并发

2.指令级并行
- 可以同时执行多条指令（流水线）
- super-scalar processor:faster than 1 inst per cycle

3.单指令、多数据并行


#### 1.9.3 sys中抽象的重要性

e.g.为一组函数规定一个简单的API

- 计算机系统中的一个重大主题就是**提供不同层次的抽象表示**，来隐藏实际实现的复杂性

下图为一些计算机系统提供的抽象：
![abstract](/images/csapp1.9.3)



### 1.10 小结

- 计算机内部的信息被表示为一组组的bit(word)
- 程序被其他程序翻译成不同的形式，直到二进制可执行文件
- 为了节省处理期读取数据的时间，按层次结构划分系统的存储设备
- 操作系统提供三个基本抽象
- 网络提供系统间的通信手段。网络可以看作一种I/O设备